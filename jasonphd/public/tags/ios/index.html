<!doctype html><html lang=en-us dir=ltr class=scroll-smooth><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"><meta name=description content><meta property="og:title" content="Ios"><meta property="og:description" content><meta property="og:url" content="https://blogs.jasonphd.com/tags/ios/"><meta property="og:site_name" content="Jasonphd Blogs"><meta property="og:type" content="website"><meta property="og:image" content="https://blogs.jasonphd.com/images/og-image.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Ios"><meta name=twitter:description content><meta name=twitter:image content="https://blogs.jasonphd.com/images/og-image.png"><title>Ios</title>
<link rel=stylesheet href=/css/output.min.97260c8f0033d223ec20178386e59725207060eda9376a3fe20db19533c0e1e7.css integrity="sha256-lyYMjwAz0iPsIBeDhuWXJSBwYO2pN2o/4g2xlTPA4ec=" crossorigin=anonymous></head><body class="bg-white text-black antialiased"><section class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="flex h-screen flex-col justify-between font-sans"><header class="flex items-center w-full bg-white justify-between py-10 sticky top-0 z-50"><a class="group break-words" aria-label="Jasonphd Blogs" href=/><div class="flex items-center justify-between"><div class=sm:mr-3><img src=/images/logo.svg width=32 height=32 alt="Logo Image"></div><div class="hidden text-2xl font-semibold sm:block group-hover:underline"><span>Jasonphd Blogs</span></div></div></a><div class="flex items-center space-x-4 leading-5 sm:space-x-6"><div class="items-center space-x-4 overflow-x-auto flex sm:space-x-6"><a href=mailto:developerluhao@gmail.com class="font-medium text-gray-900 hover:text-indigo-500">ContactMe</a>
<a href=/tags class="font-medium text-gray-900 hover:text-indigo-500">Tags</a>
<a href=/about class="font-medium text-gray-900 hover:text-indigo-500">About</a>
<a href=https://github.com/forwyt target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" class="fill-[#24292F] hover:fill-indigo-500 h-6 w-6"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.0099.0C5.36875.0.0 5.5.0 12.3042c0 5.439 3.43994 10.043 8.21205 11.6725C8.80869 24.0992 9.02724 23.712 9.02724 23.3862 9.02724 23.101 9.00757 22.1232 9.00757 21.1045 5.6667 21.838 4.97099 19.6378 4.97099 19.6378 4.43409 18.2118 3.63858 17.8452 3.63858 17.8452 2.54511 17.0915 3.71823 17.0915 3.71823 17.0915 4.93117 17.173 5.56763 18.3545 5.56763 18.3545c1.07355 1.874 2.80348 1.3445 3.49943 1.0185C9.16638 18.5785 9.48473 18.0285 9.82275 17.723 7.15817 17.4377 4.35469 16.3785 4.35469 11.6523c0-1.3445.47691-2.44455 1.2326-3.30005C5.46807 8.04675 5.0504 6.7835 5.70677 5.09275c0 0 1.01406-.326 3.30055 1.263C9.98625 6.08642 10.9958 5.9494 12.0099 5.94825c1.0141.0 2.0478.14275 3.0024.4075 2.2867-1.589 3.3008-1.263 3.3008-1.263C18.9695 6.7835 18.5515 8.04675 18.4323 8.35225 19.2079 9.20775 19.6652 10.3078 19.6652 11.6523c0 4.7262-2.8035 5.7649-5.488 6.0707C14.6148 18.11 14.9924 18.8433 14.9924 20.0045 14.9924 21.6545 14.9727 22.9788 14.9727 23.386 14.9727 23.712 15.1915 24.0992 15.7879 23.977c4.7721-1.63 8.212-6.2338 8.212-11.6728C24.0196 5.5 18.6312.0 12.0099.0z"/></svg></a></div></div></header><main class=mb-auto><div class="mx-auto max-w-4xl px-4 sm:px-6 xl:px-0"><div class="space-y-8 pb-12 pt-16"><div class=space-y-2><h1 class="text-3xl font-bold text-gray-900 sm:text-4xl uppercase"><span>Ios</span></h1></div><div class="flex flex-col gap-8 md:flex-row"><aside class="hidden md:block md:w-64"><div class="sticky top-24 space-y-8"><div class=space-y-4><h2 class="font-mono text-sm uppercase tracking-wider text-gray-500">Filter by tag</h2><nav class="inline-flex flex-col space-y-3"><a class="font-mono text-sm uppercase
text-gray-600" href=https://blogs.jasonphd.com/tags/binary/>Binary<span class="ml-2 text-gray-400">(4)</span></a>
<a class="font-mono text-sm uppercase
text-gray-600" href=https://blogs.jasonphd.com/tags/code/>Code<span class="ml-2 text-gray-400">(7)</span></a>
<a class="font-mono text-sm uppercase
text-gray-600" href=https://blogs.jasonphd.com/tags/go/>Go<span class="ml-2 text-gray-400">(1)</span></a>
<a class="font-mono text-sm uppercase
text-indigo-600 font-extrabold" href=https://blogs.jasonphd.com/tags/ios/>Ios<span class="ml-2 text-gray-400">(4)</span></a></nav></div></div></aside><div class="min-w-0 flex-1"><ul class="divide-y divide-gray-200"><li class="py-12 first:pt-0"><article><div class=space-y-8><div class=space-y-4><div class="flex flex-col gap-4 text-sm text-gray-500"><time datetime=2018-03-17T14:54:44+08:00>March 17, 2018</time><h2 class="text-2xl font-semibold text-gray-900"><a class=break-words href=https://blogs.jasonphd.com/ios/ios0/>二进制文件重排</a></h2><div class="flex flex-wrap gap-2"><a href=/tags/binary class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">binary</a>
<a href=/tags/code class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">code</a>
<a href=/tags/ios class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">ios</a></div></div><div class="text-gray-600 line-clamp-3"><p><img src=/images/ww2.webp alt=lancher title=start></p><p>名称来自战争术语 抢滩登陆 (beach head)
目的是更快的将iOS的application启动提速. 让用户更快的打开app !推广一波🤣 <a href=https://github.com/forwyt/beachhead>开源库</a></p><h2 id=进程访问内存的原理>进程访问内存的原理</h2><blockquote><p>在计算机中，<strong>进程</strong> 是操作系统分配给正在运行的程序的一种资源。它可以看作是程序的执行实例，包括程序计数器、寄存器、堆栈和打开的文件等。每个进程都在自己的<strong>虚拟地址</strong>空间中运行，这使得每个进程都有自己独立的内存空间。</p></blockquote><h3 id=虚拟地址>虚拟地址</h3><ol><li><p>地址空间划分：操作系统将每个进程的地址空间划分为多个固定大小的页。通常，每个页的大小为4KB</p></li><li><p>页表创建：操作系统为每个进程创建一个页表，用于将虚拟地址映射到物理地址。页表是一个数据结构，它记录了每个虚拟页对应的物理页的地址。</p></li><li><p>虚拟地址转换：当进程访问内存时，它使用虚拟地址。操作系统通过查找页表中的映射关系，将虚拟地址转换为物理地址。这个转换过程通常包括两个步骤。</p></li></ol><ul><li>页目录查找：进程的虚拟地址通常被划分为三个部分：页目录索引、页表索引和页内偏移。首先，操作系统使用页目录索引在页目录中查找对应的页表。</li><li>页表查找：操作系统使用页表索引在找到的页表中查找对应的物理页的地址</li></ul><ol start=4><li>内存访问：当虚拟地址被转换为物理地址后，进程可以使用物理地址来访问内存。这样，进程就可以在自己的虚拟地址空间中进行内存操作，而不需要关心物理内存的实际分布。</li></ol><p>为了提高效率和方便管理，又对虚拟内存和物理内存又进行分页（Page）。当进程访问一个虚拟内存 Page 而对应的物理内存却不存在时，会触发一次缺页中断（Page Fault），分配物理内存，有需要的话会从磁盘 <strong>mmap</strong> 读人数据。
mmap</p><blockquote><p>mmap是一种内存映射技术，它允许应用程序将文件或其他设备映射到自己的虚拟地址空间中，从而可以像访问内存一样访问这些数据。mmap可以提供高效的读写文件的方式，并且还可以用于共享内存和匿名内存映射等场景</p></blockquote><h3 id=page-fault>Page Fault</h3><blockquote><p>当进程访问一个虚拟内存 Page 而对应的物理内存却不存在时，会触发一次缺页中断（Page Fault），分配物理内存，有需要的话会从磁盘 mmap 读人数据。通过 App Store 渠道分发的 App，Page Fault 还会进行签名验证，所以一次 Page Fault 的耗时比想象的多</p></blockquote><p>1.虚拟内存允许操作系统摆脱物理 RAM 的限制。虚拟内存管理器创建一个逻辑地址空间（或“每个进程的“虚拟”地址空间）并将其划分为大小统一的内存块，称为页面。处理器及其内存管理单元（MMU）维护一个页表将程序逻辑地址空间中的页面映射到计算机 RAM 中的硬件地址。当程序代码访问内存中的地址时，MMU 使用页表将指定的逻辑地址转换为实际的硬件内存地址。这种转换是自动发生的，并且对于正在运行的应用程序是透明的。</p><p>2.对于程序而言，其逻辑地址空间中的地址始终可用。但是，如果应用程序访问当前不在物理 RAM 中的内存页上的地址，发生页面错误。当这种情况发生时，虚拟内存系统会调用一个特殊的页面错误处理程序来立即响应该错误。页面错误处理程序停止当前正在执行的代码，找到物理内存的空闲页面，从磁盘加载包含所需数据的页面，更新页表，然后将控制权返回给程序代码，程序代码可以访问内存地址通常情况下。这个过程被称为寻呼。</p><p>3.如果物理内存中没有可用的空闲页面，则处理程序必须首先释放现有页面以为新页面腾出空间。系统如何发布页面取决于平台。在 OS X 中，虚拟内存系统经常将页面写入后备存储。这后备存储是基于磁盘的存储库，其中包含给定进程使用的内存页的副本。将数据从物理内存移动到后备存储称为调出（或“交换出”）；将数据从后备存储移回物理内存称为分页（或“交换”）。在 iOS 中，没有后备存储，因此页面永远不会调出到磁盘，但只读页面仍会根据需要从磁盘调入。</p><p>4.在 OS X 和早期版本的 iOS 中，页面的大小是 4 KB。在更高版本的 iOS 中，基于 A7 和 A8 的系统向由 4 KB 物理页支持的 64 位用户空间公开 16 KB 页面，而 A9 系统公开由 16 KB 物理页支持的 16 KB 页面。这些大小决定了发生页面错误时系统从磁盘读取多少KB。当系统花费过多的时间处理页面错误以及读写页面而不是执行程序代码时，就会发生磁盘抖动。</p></div></div><a href=https://blogs.jasonphd.com/ios/ios0/ class="group inline-flex items-center text-sm text-gray-600 transition-colors hover:text-gray-900">Read Article<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="ml-1 h-4 w-4 transition-transform group-hover:translate-x-0.5"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></a></div></article></li><li class="py-12 first:pt-0"><article><div class=space-y-8><div class=space-y-4><div class="flex flex-col gap-4 text-sm text-gray-500"><time datetime=2016-09-14T15:44:54+08:00>September 14, 2016</time><h2 class="text-2xl font-semibold text-gray-900"><a class=break-words href=https://blogs.jasonphd.com/ios/ios3/>ios内存原理（3）</a></h2><div class="flex flex-wrap gap-2"><a href=/tags/binary class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">binary</a>
<a href=/tags/code class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">code</a>
<a href=/tags/ios class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">ios</a></div></div><div class="text-gray-600 line-clamp-3"><p><img src=/images/29e9bff778c21ba1fce2e366c566cc14.watch.webp alt>
虽然ARC时代不需要手动管理内存，但是我们仍然要注意循环引用和CoreFoundation对象的引用计数问题&mldr;</p><p>虽然ARC时代不需要手动管理内存，但是我们仍然要注意循环引用和CoreFoundation对象的引用计数问题</p><h3 id=mrc>MRC</h3><table><thead><tr><th style=text-align:center>对象操作</th><th style=text-align:center>OC中对应的方法</th><th style=text-align:center>对应的引用计数的化</th></tr></thead><tbody><tr><td style=text-align:center>持有对象</td><td style=text-align:center>retain</td><td style=text-align:center>+1</td></tr><tr><td style=text-align:center>释放对象</td><td style=text-align:center>release</td><td style=text-align:center>-1</td></tr><tr><td style=text-align:center>废弃对象</td><td style=text-align:center>dealloc</td><td style=text-align:center>0</td></tr></tbody></table><h3 id=arc>ARC</h3><p>根据指针来操作引用
在ARC模式下，只要没有强指针（强引用）指向对象，对象就会被释放。在ARC模式下，不允许使用retain、release、retainCount等方法。并且，如果使用dealloc方法时，不允许调用[super dealloc]方法。</p><p>ARC模式下的property变量修饰词为strong、weak，相当于MRC模式下的retain、assign。strong :代替retain，缺省关键词，代表强引用。weak：代替assign，声明了一个可以自动设置nil的弱引用，但是比assign多一个功能，指针指向的地址被释放之后，指针本身也会自动被释放。</p><p>实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化。详细的工作原理见 上一篇 <strong>内存管理(2)</strong></p><p>ARC提供四种与内存管理有关的变量标识符，分别是：</p><h3 id=关键字>关键字</h3><ul><li>__strong</li></ul><blockquote><p>__strong 是默认使用的标识符。只有还有一个强指针指向某个对象，这个对象就会一直存活。</p></blockquote><ul><li>__weak</li></ul><blockquote><p>__weak 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，弱引用会被置为 nil</p></blockquote><ul><li>_ unsafe _unretained</li></ul><blockquote><p>__unsafe_unretained 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，它不会被置为 nil。如果它引用的对象被回收掉了，该指针就变成了野指针。</p></blockquote><ul><li>__autoReleasing</li></ul><blockquote><p>__autoreleasing 用于标示使用引用传值的参数（id *），在函数返回时会被自动释放掉。</p></blockquote><p>变量标识符的用法如下，在类型和变量名之间：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>Number<span style=color:#f92672>*</span> <span style=color:#66d9ef>__strong</span> num <span style=color:#f92672>=</span> [[Number alloc] init];
</span></span></code></pre></div><p>属性标识符</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>assign</span><span style=color:#f92672>/</span><span style=color:#66d9ef>retain</span><span style=color:#f92672>/</span><span style=color:#66d9ef>strong</span><span style=color:#f92672>/</span><span style=color:#66d9ef>weak</span><span style=color:#f92672>/</span><span style=color:#66d9ef>unsafe_unretained</span><span style=color:#f92672>/</span><span style=color:#66d9ef>copy</span>) Number<span style=color:#f92672>*</span> num
</span></span></code></pre></div><p>assign表明 setter 仅仅是一个简单的赋值操作，通常用于基本的数值类型，例如CGFloat和NSInteger。</p><table><thead><tr><th>key</th><th>含义</th></tr></thead><tbody><tr><td>strong</td><td>表明属性定义一个拥有者关系。当给属性设定一个新值的时候，首先这个值进行 retain ，旧值进行 release ，然后进行赋值操作。</td></tr><tr><td>weak</td><td>表明属性定义了一个非拥有者关系。当给属性设定一个新值的时候，这个值不会进行 retain，旧值也不会进行 release， 而是进行类似 assign 的操作。不过当属性指向的对象被销毁时，该属性会被置为nil</td></tr><tr><td>unsafe_unretained</td><td>语义和 assign 类似，不过是用于对象类型的，表示一个非拥有(unretained)的，同时也不会在对象被销毁时置为nil的(unsafe)关系</td></tr><tr><td>copy</td><td>类似于 strong，不过在赋值时进行 copy 操作而不是 retain 操作。通常在需要保留某个不可变对象（NSString最常见），并且防止它被意外改变时使用</td></tr><tr><td>unsafe_unretained</td><td>（1）兼容性，iOS4之前没有weak只能用unsafe_unretained（2）性能考虑，性能比weak要好</td></tr></tbody></table><h3 id=arc下仍然需要注意的内存管理问题>ARC下仍然需要注意的内存管理问题</h3><p>循环引用问题。
当两个对象互相持有对方的强引用时，并且这两个对象的引用计数都不是0的时候，便造成了引用循环，从而使用计数后内存无法得到释放。可以从以下几个方面入手：</p></div></div><a href=https://blogs.jasonphd.com/ios/ios3/ class="group inline-flex items-center text-sm text-gray-600 transition-colors hover:text-gray-900">Read Article<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="ml-1 h-4 w-4 transition-transform group-hover:translate-x-0.5"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></a></div></article></li><li class="py-12 first:pt-0"><article><div class=space-y-8><div class=space-y-4><div class="flex flex-col gap-4 text-sm text-gray-500"><time datetime=2016-09-12T14:44:52+08:00>September 12, 2016</time><h2 class="text-2xl font-semibold text-gray-900"><a class=break-words href=https://blogs.jasonphd.com/ios/ios2/>ios内存原理（2）</a></h2><div class="flex flex-wrap gap-2"><a href=/tags/binary class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">binary</a>
<a href=/tags/code class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">code</a>
<a href=/tags/ios class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">ios</a></div></div><div class="text-gray-600 line-clamp-3"><p><img src=/images/9fb61babf6f061ea4929598c55cd8c2e.programming-1873854_1920.webp alt>
经过前面文档我们大致了解了arc/mrc机制,是为了更好的去做iOS的内存管理</p><blockquote><p>前言</p></blockquote><p>经过前面文档我们大致了解了arc/mrc机制,是为了更好的去做iOS的内存管理.在面对一个对象的时候,从初始化到delloc销毁的过程中进行合适的插入 <em>retain</em> 和 <em>release</em> 做到内存的回收释放♻️,随着iOS的迭代发展,我们开始逐渐采用一种解放程序员的新型管理模式 ARC &mldr;</p><h3 id=什么是arcmrc>什么是ARC/MRC</h3><p><strong>Manual Reference Counting</strong> 是根据对象的引用计数器 <strong>reference count</strong> 来判断在何时将一个对象所占用的内存回收
<strong>Automatic Reference Counting</strong> 自动引用计数 是苹果子WWDC2011年引入的,其工作原理下面详细理解,根本上是通过强指针来判断</p><h3 id=autoreleasepool>AutoreleasePool</h3><blockquote><p>从main函数开始了解:</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> argv[]) {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>@autoreleasepool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate <span style=color:#66d9ef>class</span>]));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个autoreleasepool的block里面 所有的事件,消息,全部转交给了<strong>UIApplication</strong>来处理,从此可以看出一个iOS应用是完全包裹在自动释放池里面的</p><p>通过clang 编译器将main函数转换成了 main.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>$</span> clang <span style=color:#f92672>-</span>rewrite<span style=color:#f92672>-</span>objc main.m
</span></span></code></pre></div><p>我们将关注点放在__AtAutoreleasePool这个结构体上面</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__AtAutoreleasePool</span> {
</span></span><span style=display:flex><span>  __AtAutoreleasePool() {atautoreleasepoolobj <span style=color:#f92672>=</span> objc_autoreleasePoolPush();}
</span></span><span style=display:flex><span>  <span style=color:#f92672>~</span>__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj);}
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> atautoreleasepoolobj;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>不难看出我们main函数的工作原理大致上是在初始化时候调用了</p><pre tabindex=0><code>void * atautoreleasepoolobj = objc_autoreleasePoolPush();
</code></pre><p>然后在析构时候调用了</p><pre tabindex=0><code>objc_autoreleasePoolPop(atautoreleasepoolobj);```

所以@autoreleasepool会被转换成上面两行代码

&gt; objc_autoreleasePoolPush

从[源码](https://opensource.apple.com/source/objc4/objc4-532/runtime/NSObject.mm.auto.html &#34;标题&#34;)中我们看到

```objc
void *_objc_autoreleasePoolPush(void) { return objc_autoreleasePoolPush(); }
void _objc_autoreleasePoolPop(void *ctxt) { objc_autoreleasePoolPop(ctxt); }

void *
objc_autoreleasePoolPush(void)
{
    if (UseGC) return NULL;
    return AutoreleasePoolPage::push();
}

void
objc_autoreleasePoolPop(void *ctxt)
{
    if (UseGC) return;

    // fixme rdar://9167170
    if (!ctxt) return;

    AutoreleasePoolPage::pop(ctxt);
}
</code></pre><p>push和pop是操作这一个 <strong>AutoreleasePoolPage</strong> 对象</p></div></div><a href=https://blogs.jasonphd.com/ios/ios2/ class="group inline-flex items-center text-sm text-gray-600 transition-colors hover:text-gray-900">Read Article<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="ml-1 h-4 w-4 transition-transform group-hover:translate-x-0.5"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></a></div></article></li><li class="py-12 first:pt-0"><article><div class=space-y-8><div class=space-y-4><div class="flex flex-col gap-4 text-sm text-gray-500"><time datetime=2016-09-10T09:43:12+08:00>September 10, 2016</time><h2 class="text-2xl font-semibold text-gray-900"><a class=break-words href=https://blogs.jasonphd.com/ios/ios1/>ios内存原理（1）</a></h2><div class="flex flex-wrap gap-2"><a href=/tags/binary class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">binary</a>
<a href=/tags/code class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">code</a>
<a href=/tags/ios class="mr-3 text-sm font-medium uppercase text-indigo-500 hover:text-indigo-600">ios</a></div></div><div class="text-gray-600 line-clamp-3"><p><img src=/images/eb99c63605e608e7e685dc8c9d04603d.board1.webp alt=board1.jpg>
在iOS的开发中我们接触到了ARC/MRC这些机制,为了更好的了解其中的原理,我们可以从官方的文档作为入口来看看这些名词背后更深入的意义.</p><p>在iOS的开发中我们接触到了ARC/MRC这些机制,为了更好的了解其中的原理,我们可以从官方的文档作为入口来看看这些名词背后更深入的意义.</p><h2 id=01内存管理>01内存管理</h2><p><img src=https://jasonphd.com/pic/shentu.jpg alt>
基本内存管理规则内存管理模型基于对象所有权。任何对象都可以具有一个或多个所有者。只要一个对象至少具有一个所有者，它就会继续存在。如果对象没有所有者，则运行时系统会自动销毁它.</p><p>苹果给出了四条准则</p><ul><li>管理任何由你自己创建的对象</li><li>通过retain来持有一个对象 (在对象方法/init方法中调用 )一般在下面两种情况<ul><li>当你想将一个对象存储为属性值时</li></ul><ul><li>当你想防止一个对象被释放时</li></ul></li><li>当你不再需要这个对象时候 请释放</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>    Person <span style=color:#f92672>*</span>aPerson <span style=color:#f92672>=</span> [[Person alloc] init];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    NSString <span style=color:#f92672>*</span>name <span style=color:#f92672>=</span> aPerson.fullName;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    [aPerson <span style=color:#66d9ef>release</span>];
</span></span></code></pre></div><p>tips
1.在iOS中涉及到对象持有的是基于一套 <em>NSObject protocol</em>协议 以及一些标准的方法名来实现的,例如alloc,newObject,copy,mutableCopy来实现的</p><p>2.管理对象,我们从Apple给出的两个例子</p><p>当你担心你的对象alloc后,在return之前调用[object release]导致对象被释放 那么采用autorelease,该方法会在返回对象之后调用release方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>- (NSString <span style=color:#f92672>*</span>)<span style=color:#a6e22e>fullName</span> {
</span></span><span style=display:flex><span>    NSString <span style=color:#f92672>*</span>string <span style=color:#f92672>=</span> [[[NSString alloc] initWithFormat:<span style=color:#e6db74>@&#34;%@ %@&#34;</span>,
</span></span><span style=display:flex><span>                                          self.firstName, self.lastName] autorelease];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> string;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面这种方法是在调用者调用此方法之后 对象被销毁之前达到将对象传递给外面的效果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>- (NSString <span style=color:#f92672>*</span>)<span style=color:#a6e22e>fullName</span> {
</span></span><span style=display:flex><span>    NSString <span style=color:#f92672>*</span>string <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;%@ %@&#34;</span>,
</span></span><span style=display:flex><span>                                 self.firstName, self.lastName];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> string;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们也可以通过ClassName 或者 id 去完成我们的逻辑操作例如&amp;object指向内存地址 ,所以我们不持有对象就无需去管理对象</p></div></div><a href=https://blogs.jasonphd.com/ios/ios1/ class="group inline-flex items-center text-sm text-gray-600 transition-colors hover:text-gray-900">Read Article<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="ml-1 h-4 w-4 transition-transform group-hover:translate-x-0.5"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></a></div></article></li></ul></div></div></div></div></main><footer><div class="mt-16 flex flex-col items-center"><div class="mb-2 text-sm text-gray-500"><span>(C) 2025. Jasonphd Blogs all rights reserved.</span></div><div class="mb-8 text-sm text-gray-500"><span class=mr-1>Built with</span>
<a class="font-semibold underline" href=https://github.com/discaptive/hugo-discaptive target=_blank>hugo-discaptive</a></div></div></footer></div></section></body></html>
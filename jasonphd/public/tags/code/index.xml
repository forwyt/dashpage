<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code on Jasonphd Blogs</title>
    <link>https://blogs.jasonphd.com/tags/code/</link>
    <description>Recent content in Code on Jasonphd Blogs</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 17 Mar 2018 14:54:44 +0800</lastBuildDate>
    <atom:link href="https://blogs.jasonphd.com/tags/code/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>二进制文件重排</title>
      <link>https://blogs.jasonphd.com/ios/ios0/</link>
      <pubDate>Sat, 17 Mar 2018 14:54:44 +0800</pubDate>
      <guid>https://blogs.jasonphd.com/ios/ios0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://blogs.jasonphd.com/images/ww2.webp&#34; alt=&#34;lancher&#34; title=&#34;start&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;名称来自战争术语 抢滩登陆 (beach head)&#xA;目的是更快的将iOS的application启动提速. 让用户更快的打开app !推广一波🤣 &lt;a href=&#34;https://github.com/forwyt/beachhead&#34;&gt;开源库&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;进程访问内存的原理&#34;&gt;进程访问内存的原理&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在计算机中，&lt;strong&gt;进程&lt;/strong&gt; 是操作系统分配给正在运行的程序的一种资源。它可以看作是程序的执行实例，包括程序计数器、寄存器、堆栈和打开的文件等。每个进程都在自己的&lt;strong&gt;虚拟地址&lt;/strong&gt;空间中运行，这使得每个进程都有自己独立的内存空间。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;虚拟地址&#34;&gt;虚拟地址&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;地址空间划分：操作系统将每个进程的地址空间划分为多个固定大小的页。通常，每个页的大小为4KB&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;页表创建：操作系统为每个进程创建一个页表，用于将虚拟地址映射到物理地址。页表是一个数据结构，它记录了每个虚拟页对应的物理页的地址。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;虚拟地址转换：当进程访问内存时，它使用虚拟地址。操作系统通过查找页表中的映射关系，将虚拟地址转换为物理地址。这个转换过程通常包括两个步骤。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;页目录查找：进程的虚拟地址通常被划分为三个部分：页目录索引、页表索引和页内偏移。首先，操作系统使用页目录索引在页目录中查找对应的页表。&lt;/li&gt;&#xA;&lt;li&gt;页表查找：操作系统使用页表索引在找到的页表中查找对应的物理页的地址&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;内存访问：当虚拟地址被转换为物理地址后，进程可以使用物理地址来访问内存。这样，进程就可以在自己的虚拟地址空间中进行内存操作，而不需要关心物理内存的实际分布。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;为了提高效率和方便管理，又对虚拟内存和物理内存又进行分页（Page）。当进程访问一个虚拟内存 Page 而对应的物理内存却不存在时，会触发一次缺页中断（Page Fault），分配物理内存，有需要的话会从磁盘 &lt;strong&gt;mmap&lt;/strong&gt; 读人数据。&#xA;mmap&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;mmap是一种内存映射技术，它允许应用程序将文件或其他设备映射到自己的虚拟地址空间中，从而可以像访问内存一样访问这些数据。mmap可以提供高效的读写文件的方式，并且还可以用于共享内存和匿名内存映射等场景&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;page-fault&#34;&gt;Page Fault&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;当进程访问一个虚拟内存 Page 而对应的物理内存却不存在时，会触发一次缺页中断（Page Fault），分配物理内存，有需要的话会从磁盘 mmap 读人数据。通过 App Store 渠道分发的 App，Page Fault 还会进行签名验证，所以一次 Page Fault 的耗时比想象的多&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;1.虚拟内存允许操作系统摆脱物理 RAM 的限制。虚拟内存管理器创建一个逻辑地址空间（或“每个进程的“虚拟”地址空间）并将其划分为大小统一的内存块，称为页面。处理器及其内存管理单元（MMU）维护一个页表将程序逻辑地址空间中的页面映射到计算机 RAM 中的硬件地址。当程序代码访问内存中的地址时，MMU 使用页表将指定的逻辑地址转换为实际的硬件内存地址。这种转换是自动发生的，并且对于正在运行的应用程序是透明的。&lt;/p&gt;&#xA;&lt;p&gt;2.对于程序而言，其逻辑地址空间中的地址始终可用。但是，如果应用程序访问当前不在物理 RAM 中的内存页上的地址，发生页面错误。当这种情况发生时，虚拟内存系统会调用一个特殊的页面错误处理程序来立即响应该错误。页面错误处理程序停止当前正在执行的代码，找到物理内存的空闲页面，从磁盘加载包含所需数据的页面，更新页表，然后将控制权返回给程序代码，程序代码可以访问内存地址通常情况下。这个过程被称为寻呼。&lt;/p&gt;&#xA;&lt;p&gt;3.如果物理内存中没有可用的空闲页面，则处理程序必须首先释放现有页面以为新页面腾出空间。系统如何发布页面取决于平台。在 OS X 中，虚拟内存系统经常将页面写入后备存储。这后备存储是基于磁盘的存储库，其中包含给定进程使用的内存页的副本。将数据从物理内存移动到后备存储称为调出（或“交换出”）；将数据从后备存储移回物理内存称为分页（或“交换”）。在 iOS 中，没有后备存储，因此页面永远不会调出到磁盘，但只读页面仍会根据需要从磁盘调入。&lt;/p&gt;&#xA;&lt;p&gt;4.在 OS X 和早期版本的 iOS 中，页面的大小是 4 KB。在更高版本的 iOS 中，基于 A7 和 A8 的系统向由 4 KB 物理页支持的 64 位用户空间公开 16 KB 页面，而 A9 系统公开由 16 KB 物理页支持的 16 KB 页面。这些大小决定了发生页面错误时系统从磁盘读取多少KB。当系统花费过多的时间处理页面错误以及读写页面而不是执行程序代码时，就会发生磁盘抖动。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
